# 递归函数

如果一个函数在内部调用自身本身，这个函数就是递归函数。

递归应用示例：

```python
# 计算阶乘
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
```

递归函数的优点是定义简单，逻辑清晰。
理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。

## 栈溢出

使用递归函数需要注意防止栈溢出。

在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。
由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。

解决递归调用栈溢出的方法是通过 **尾递归** 优化。
事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

### 尾递归

尾递归是指，

1. **在函数返回的时候，调用自身本身**，并且，
2. **`return` 语句不能包含表达式**。

`return n * fact(n - 1)` 包含了乘法表达式，所以不是尾递归。

这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

> 如何写尾递归：
> 形式上，只要最后一个 `return` 语句是单纯的函数就可以，比如 `return func()`。

将计算阶乘改成尾递归的方式：

```python
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
```

尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。

> 尾递归，比线性递归多一个参数，这个参数是上一次调用函数得到的结果；
> 所以，关键点在于，尾递归每次调用都在收集结果，避免了线性递归不收集结果只能依次展开消耗内存的坏处。

遗憾的是，大多数编程语言没有针对尾递归做优化，Python标准的解释器也没有做优化，所以，即使把上面的 `fact(n)` 函数改成尾递归方式，也会导致栈溢出。

> Rust 有提供优化。
